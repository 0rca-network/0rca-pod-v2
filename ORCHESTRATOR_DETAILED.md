# Orchestrator System - Complete Technical Documentation

## Overview

The Orchestrator is a multi-agent workflow system that allows users to submit natural language requests and automatically chains multiple AI agents together to accomplish complex tasks.

## System Architecture

### Data Flow

```
User Input → OpenAI Planning → Workflow Creation → Sequential Execution → Final Output
```

### Core Components

1. **Frontend Pages**
   - `/orchestrator` - User input interface
   - `/workflow/[workflow_id]` - Workflow execution and monitoring

2. **Backend Logic**
   - `lib/orchestrator.ts` - Core orchestration functions
   - API routes in `pages/api/workflows/`

3. **Database Tables** (Supabase)
   - `workflows` - Stores workflow records
   - `step_results` - Tracks individual step execution
   - `agents` - Available AI agents

4. **Type Definitions**
   - `types/orchestrator.ts` - TypeScript interfaces

---

## Database Schema

### `workflows` Table

Stores the main workflow record with the AI-generated plan.

```sql
CREATE TABLE workflows (
  workflow_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_message TEXT NOT NULL,           -- Original user request
  wallet_address VARCHAR(58) NOT NULL,  -- User's Algorand wallet
  plan JSONB NOT NULL,                  -- AI-generated WorkflowPlan
  status VARCHAR(50) DEFAULT 'planned', -- planned|approved|running|completed|failed
  current_step INTEGER DEFAULT 0,       -- Current executing step number
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

**Status Flow:**
- `planned` → User reviews the plan
- `approved` → User approved, ready to start
- `running` → Currently executing steps
- `completed` → All steps finished successfully
- `failed` → A step failed

### `step_results` Table

Tracks execution state for each step in the workflow.

```sql
CREATE TABLE step_results (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workflow_id UUID REFERENCES workflows(workflow_id),
  step_number INTEGER NOT NULL,
  agent_id UUID REFERENCES agents(id),
  agent_name VARCHAR(255),
  agent_job_id VARCHAR(255),            -- Job ID from agent's API
  status VARCHAR(50) DEFAULT 'pending', -- pending|awaiting_payment|payment_confirmed|running|succeeded|failed
  output TEXT,                          -- Agent's output (passed to next step)
  access_token TEXT,                    -- Token to poll agent
  txn_ids TEXT[],                       -- Blockchain transaction IDs
  unsigned_group_txns TEXT[],           -- Unsigned transactions from agent
  completed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);
```

**Status Flow:**
- `pending` → Waiting to execute
- `awaiting_payment` → Job created, waiting for blockchain payment
- `payment_confirmed` → Payment verified, agent processing
- `running` → Agent is executing
- `succeeded` → Step completed with output
- `failed` → Step failed

---

## TypeScript Interfaces

### WorkflowStep
Defines a single step in the workflow plan.

```typescript
interface WorkflowStep {
  step_number: number;      // Sequential step number (1, 2, 3...)
  agent_id: string;         // UUID of the agent to use
  agent_name: string;       // Human-readable agent name
  description: string;      // What this step does
  input_schema: any;        // Expected input format
  input_data: any;          // Actual input for this step
}
```

### WorkflowPlan
The complete plan generated by OpenAI.

```typescript
interface WorkflowPlan {
  reasoning: string;        // AI's explanation of the workflow
  steps: WorkflowStep[];    // Array of steps to execute
}
```

### WorkflowRecord
Complete workflow database record.

```typescript
interface WorkflowRecord {
  workflow_id: string;
  user_message: string;
  wallet_address: string;
  plan: WorkflowPlan;
  status: string;
  current_step: number;
  created_at: string;
  updated_at: string;
}
```

### StepResult
Execution state for a single step.

```typescript
interface StepResult {
  id: string;
  workflow_id: string;
  step_number: number;
  agent_id: string;
  agent_name: string;
  agent_job_id?: string;
  status: string;
  output?: string;
  access_token?: string;
  txn_ids?: string[];
  unsigned_group_txns?: string[];
  completed_at?: string;
  agent?: any;
}
```

---

## Core Functions (lib/orchestrator.ts)

### 1. planWorkflow()

Creates a new workflow from user input using OpenAI.

```typescript
async function planWorkflow(
  userMessage: string, 
  walletAddress: string
): Promise<{ workflow_id: string; plan: WorkflowPlan }>
```

**Process:**
1. Fetches all active agents from database
2. Builds prompt with agent metadata
3. Calls OpenAI GPT-4 to generate plan
4. Inserts workflow record into `workflows` table
5. Creates `step_results` records for each step (status: 'pending')
6. Returns workflow_id and plan

**OpenAI Prompt Structure:**
- System: "You are a workflow orchestrator..."
- User: Includes user message + all available agents with their capabilities
- Response: JSON with reasoning and steps array

### 2. approveWorkflow()

Marks workflow as approved by user.

```typescript
async function approveWorkflow(workflowId: string): Promise<void>
```

Updates `workflows.status` from 'planned' → 'approved'

### 3. startWorkflow()

Begins workflow execution.

```typescript
async function startWorkflow(workflowId: string): Promise<void>
```

Updates `workflows.status` to 'running' and sets `current_step` to 1

### 4. createAgentJob()

Starts a job on an agent for a specific step.

```typescript
async function createAgentJob(
  workflowId: string,
  stepNumber: number,
  walletAddress: string
): Promise<{ stepResultId: string; jobData: any }>
```

**Process:**
1. Fetches workflow plan and step details
2. Gets input_data from plan
3. If step > 1, fetches previous step's output and merges it
4. Calls agent's `/start_job` endpoint
5. Receives `job_id` and `unsigned_group_txns`
6. Updates `step_results` with job data (status: 'awaiting_payment')
7. Returns stepResultId and jobData for frontend signing

### 5. submitPayment()

Verifies blockchain payment with the agent.

```typescript
async function submitPayment(
  stepResultId: string,
  txnIds: string[]
): Promise<any>
```

**Process:**
1. Fetches step result and agent info
2. Calls agent's `/submit_payment` endpoint with job_id and txn_ids
3. Receives `access_token` from agent
4. Updates `step_results` with access_token and txn_ids (status: 'payment_confirmed')
5. Returns payment verification response

### 6. pollAgentJob()

Polls agent for job completion status.

```typescript
async function pollAgentJob(
  stepResultId: string
): Promise<{ status: string; output?: string }>
```

**Process:**
1. Fetches step result with access_token
2. Calls agent's `/job/{job_id}?access_token=...` endpoint
3. If status is 'succeeded':
   - Updates `step_results` with output (status: 'succeeded')
   - Returns output
4. If status is 'failed':
   - Updates `step_results` (status: 'failed')
5. If still running:
   - Updates status to 'running'
   - Returns current status

### 7. advanceWorkflow()

Moves workflow to the next step or completes it.

```typescript
async function advanceWorkflow(
  workflowId: string
): Promise<{ completed: boolean; nextStep?: number }>
```

**Process:**
1. Fetches workflow's current_step and total steps
2. If current_step >= total steps:
   - Updates workflow status to 'completed'
   - Returns { completed: true }
3. Otherwise:
   - Increments current_step
   - Returns { completed: false, nextStep: X }

---

## API Routes

### POST /api/workflows/create

Creates a new workflow from user message.

**Request:**
```json
{
  "userMessage": "I have a headache and want a movie recommendation",
  "walletAddress": "ALGO_ADDRESS"
}
```

**Response:**
```json
{
  "workflow_id": "uuid",
  "plan": {
    "reasoning": "...",
    "steps": [...]
  }
}
```

### POST /api/workflows/approve

Approves a workflow.

**Request:**
```json
{
  "workflowId": "uuid"
}
```

### POST /api/workflows/start

Starts workflow execution.

**Request:**
```json
{
  "workflowId": "uuid"
}
```

### GET /api/workflows/[id]

Gets workflow status and all step results.

**Response:**
```json
{
  "workflow": { WorkflowRecord },
  "steps": [ StepResult[] ]
}
```

### POST /api/workflows/step/start_job

Starts a job for a specific step.

**Request:**
```json
{
  "workflowId": "uuid",
  "stepNumber": 1,
  "walletAddress": "ALGO_ADDRESS"
}
```

**Response:**
```json
{
  "stepResultId": "uuid",
  "jobData": {
    "job_id": "...",
    "unsigned_group_txns": ["base64..."]
  }
}
```

### POST /api/workflows/step/submit_payment

Submits payment verification after signing.

**Request:**
```json
{
  "stepResultId": "uuid",
  "txnIds": ["TXN_ID"]
}
```

### POST /api/workflows/step/poll

Polls for step completion and advances workflow.

**Request:**
```json
{
  "stepResultId": "uuid",
  "workflowId": "uuid"
}
```

**Response:**
```json
{
  "status": "succeeded",
  "output": "...",
  "completed": false,
  "nextStep": 2
}
```

---

## Frontend Flow

### Page: /orchestrator

User input interface.

**Components:**
- Text area for user message
- Submit button (requires wallet connection)
- "How it works" explanation

**Actions:**
1. User enters request
2. Clicks "Create Workflow"
3. Calls `POST /api/workflows/create`
4. Redirects to `/workflow/[workflow_id]`

### Page: /workflow/[workflow_id]

Workflow execution and monitoring.

**Display:**
- Workflow status badge
- AI reasoning
- List of steps with status indicators
- Step outputs when available

**User Actions:**
1. **Approve & Start** button (if status is 'planned')
   - Calls approve and start APIs
   - Begins executeNextStep()

**Automatic Execution:**

```javascript
executeNextStep() {
  1. Find first pending step
  2. Call /api/workflows/step/start_job
  3. Receive unsigned_group_txns
  4. Sign transactions using wallet
  5. Submit to blockchain
  6. Call /api/workflows/step/submit_payment
  7. Start polling with pollStep()
}

pollStep() {
  1. Call /api/workflows/step/poll every 3 seconds
  2. If succeeded:
     - Display output
     - If not completed, call executeNextStep() for next step
  3. If failed:
     - Display error
  4. If running:
     - Continue polling
}
```

---

## Complete Execution Example

### User Request
```
"I have a headache and runny nose and want a movie recommendation"
```

### Step 1: Workflow Creation

**POST /api/workflows/create**

OpenAI generates:
```json
{
  "reasoning": "User needs medical diagnosis first, then entertainment based on their condition",
  "steps": [
    {
      "step_number": 1,
      "agent_id": "medical-agent-uuid",
      "agent_name": "Medical Diagnosis Agent",
      "description": "Diagnose symptoms",
      "input_data": {
        "symptoms": "headache, runny nose"
      }
    },
    {
      "step_number": 2,
      "agent_id": "movie-agent-uuid",
      "agent_name": "Movie Recommendation Agent",
      "description": "Recommend movies for condition",
      "input_data": {
        "preferences": "relaxing"
      }
    }
  ]
}
```

**Database State:**

`workflows` table:
```
workflow_id: abc-123
user_message: "I have a headache..."
status: planned
current_step: 0
plan: { reasoning, steps }
```

`step_results` table:
```
Row 1: step_number=1, agent_id=medical-agent-uuid, status=pending
Row 2: step_number=2, agent_id=movie-agent-uuid, status=pending
```

### Step 2: User Approval

User clicks "Approve & Start"

**POST /api/workflows/approve**
- Updates workflow status: 'planned' → 'approved'

**POST /api/workflows/start**
- Updates workflow status: 'approved' → 'running'
- Sets current_step: 1

### Step 3: Execute Step 1

**POST /api/workflows/step/start_job**
```json
{
  "workflowId": "abc-123",
  "stepNumber": 1,
  "walletAddress": "USER_WALLET"
}
```

Backend calls:
```
POST https://medical-agent.0rca.live/start_job
{
  "sender_address": "USER_WALLET",
  "job_input": { "symptoms": "headache, runny nose" }
}
```

Agent responds:
```json
{
  "job_id": "job-xyz",
  "unsigned_group_txns": ["base64_txn_1", "base64_txn_2"]
}
```

**Database Update:**
```
step_results (step 1):
  agent_job_id: job-xyz
  unsigned_group_txns: [...]
  status: awaiting_payment
```

### Step 4: Payment

Frontend:
1. Decodes unsigned_group_txns
2. Signs with user's wallet
3. Submits to Algorand blockchain
4. Gets transaction ID

**POST /api/workflows/step/submit_payment**
```json
{
  "stepResultId": "step-1-id",
  "txnIds": ["TXN_ABC123"]
}
```

Backend calls:
```
POST https://medical-agent.0rca.live/submit_payment
{
  "job_id": "job-xyz",
  "txid": ["TXN_ABC123"]
}
```

Agent responds:
```json
{
  "status": "success",
  "access_token": "token-123"
}
```

**Database Update:**
```
step_results (step 1):
  access_token: token-123
  txn_ids: [TXN_ABC123]
  status: payment_confirmed
```

### Step 5: Poll Step 1

**POST /api/workflows/step/poll** (every 3 seconds)

Backend calls:
```
GET https://medical-agent.0rca.live/job/job-xyz?access_token=token-123
```

Agent responds (after processing):
```json
{
  "status": "succeeded",
  "output": "Likely common cold. Recommend rest and fluids."
}
```

**Database Update:**
```
step_results (step 1):
  status: succeeded
  output: "Likely common cold..."
  completed_at: NOW()

workflows:
  current_step: 2
```

### Step 6: Execute Step 2

**POST /api/workflows/step/start_job**
```json
{
  "workflowId": "abc-123",
  "stepNumber": 2,
  "walletAddress": "USER_WALLET"
}
```

Backend:
1. Fetches step 2 input_data: `{ "preferences": "relaxing" }`
2. Fetches step 1 output: `"Likely common cold..."`
3. Merges: `{ "preferences": "relaxing", "previous_output": "Likely common cold..." }`

Calls:
```
POST https://movie-agent.0rca.live/start_job
{
  "sender_address": "USER_WALLET",
  "job_input": {
    "preferences": "relaxing",
    "previous_output": "Likely common cold..."
  }
}
```

### Step 7: Payment & Poll Step 2

Same process as Step 1...

Agent eventually responds:
```json
{
  "status": "succeeded",
  "output": "Recommended movies: The Grand Budapest Hotel, Amélie, Paddington"
}
```

**Database Update:**
```
step_results (step 2):
  status: succeeded
  output: "Recommended movies..."
  completed_at: NOW()

workflows:
  status: completed
  current_step: 2
```

### Final State

User sees on `/workflow/abc-123`:
- ✅ Step 1: Medical Diagnosis Agent - "Likely common cold..."
- ✅ Step 2: Movie Recommendation Agent - "Recommended movies: ..."
- Status: Completed

---

## Key Design Decisions

### 1. Sequential Execution
Steps execute one at a time, not in parallel. This allows outputs to flow between steps.

### 2. Reuses Existing Hire Logic
The orchestrator doesn't reinvent payment handling. It uses the same agent APIs (`/start_job`, `/submit_payment`) that the single-agent hire flow uses.

### 3. Frontend Handles Signing
Transaction signing happens in the browser using the user's wallet. Backend never touches private keys.

### 4. Polling for Results
After payment, the system polls the agent's `/job/{id}` endpoint until status is 'succeeded' or 'failed'.

### 5. OpenAI for Planning
GPT-4 analyzes the user request and available agents to create an optimal workflow plan.

### 6. Type Safety
All data structures are strongly typed in TypeScript for reliability.

---

## Error Handling

### Agent Failure
If a step fails, the workflow status becomes 'failed' and execution stops.

### Payment Failure
If blockchain transaction fails, the step remains in 'awaiting_payment' and can be retried.

### Timeout
Polling has implicit timeout (frontend stops polling after X attempts).

### Invalid Plan
If OpenAI generates invalid JSON, the workflow creation fails with error.

---

## Environment Variables

Required in `.env`:

```bash
# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...
SUPABASE_SERVICE_ROLE_KEY=eyJ...

# OpenAI
OPENAI_API_KEY=sk-proj-...
```

---

## Summary

The Orchestrator system enables complex multi-agent workflows by:

1. **Planning** - Using OpenAI to analyze requests and create step-by-step plans
2. **Storage** - Tracking workflow and step state in Supabase
3. **Execution** - Sequentially calling agents and passing outputs between steps
4. **Payment** - Integrating with Algorand blockchain for agent payments
5. **Monitoring** - Providing real-time status updates to users

All components are type-safe, modular, and integrate seamlessly with the existing agent marketplace infrastructure.
